# synchronized 四种锁状态
在 JDK 1.6 以前，所有的锁都是”重量级“锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入**synchronized **块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。
这也是为什么很多开发者会认为 synchronized 性能很差的原因。
那为了减少获得锁和释放锁带来的性能消耗，JDK 1.6 引入了“偏向锁”和“轻量级锁” 的概念，对 synchronized 做了一次重大的升级，升级后的 synchronized 性能可以说上了一个新台阶。
在 JDK 1.6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：

1. 无锁状态
2. 偏向锁状态
3. 轻量级锁状态
4. 重量级锁状态

无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，很好理解。
几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件就比较苛刻了，锁降级发生在 Stop The World（Java 垃圾回收中的一个重要概念）期间，当 JVM 进入安全点的时候，会检查是否有闲置的锁，然后进行降级。
### 锁降级
锁降级是一个在并发编程中用来描述锁状态变化的术语，特别是在Java中，它指的是从一个重量级锁（Heavyweight Lock）状态降级到一个轻量级锁（Lightweight Lock）或偏向锁（Biased Lock）的过程。然而，实际上在Java的实现中，锁降级并不常见或者说并非典型行为，因为一旦锁升级到重量级锁，通常在锁的整个生命周期内都会保持这种状态。不过，为了解释这个概念，我们可以用一个现实世界的类比来帮助理解。
#### 现实案例：银行排队
假设银行有多个服务窗口和一个等待区，人们按需排队等待服务。这个过程中，我们可以将不同的服务方式比作不同类型的锁：

1. **偏向锁** - 当银行刚开门，只有一个顾客进入，这时候只有一个服务窗口开放，顾客直接接受服务，没有等待。这像偏向锁，因为系统偏向于这一个顾客，没有竞争。
2. **轻量级锁** - 当开始有更多顾客到来，但人数还不多，顾客可能需要短暂等待，但整体流程仍然很快。此时，服务窗口可能适度增加，服务人员和顾客之间通过快速的交流（相当于自旋）来处理业务。这像轻量级锁，涉及一些竞争但没有大规模的阻塞。
3. **重量级锁** - 银行非常忙碌时，顾客需要取号等待，每个窗口前都排着长队。服务效率下降，顾客的等待时间增加。这像重量级锁，涉及到大量的等待和资源竞争。
#### 锁降级的类比
在一个非常理想的情况下，如果银行在繁忙时段之后突然客流量减少，银行可能决定关闭一些服务窗口，但仍保持比最开始更多的窗口开放以应对可能的需求。这时，即使顾客的数量减少到了接近开门时的水平，银行也可能选择保持一定数量的窗口开放而不是只开一个窗口，这可以看作是一种“锁降级”，从重量级的处理方式降级到一个较轻的处理方式，但并没有完全回到最初的偏向一个顾客的状态。
在实际的Java并发编程实践中，锁的状态变化主要还是偏向锁升级到轻量级锁，然后可能升级到重量级锁，而从重量级锁降级到轻量级锁的情况则较为罕见。通常，锁的状态一旦升级，就很难降级，因为这样做可能会引入复杂性和性能开销，而现代的JVM优化已经足够智能，能够根据实际情况调整锁的策略以优化性能。
> 上方回答来自 GPT4

## 偏向锁
偏向锁是Java虚拟机（JVM）为了减少锁操作的开销而引入的一种锁优化机制。其基本思想是，如果一个锁被一个线程多次连续地获得，那么可以把这个锁偏向于该线程，让它以后获得这个锁时不需要进行额外的同步操作。这种偏向模式可以减少不必要的锁竞争开销，因为实际应用中很多锁在整个生命周期内都只被一个线程所使用。
### 工作原理

1. **锁标记**：当一个线程首次获得锁时，JVM会在对象头中的锁标记字段中记录这个线程的ID，这个过程称为锁的偏向。
2. **无竞争获取**：之后，当相同的线程再次请求这个锁时，JVM只需简单地检查对象头中的线程ID是否为当前线程的ID。如果是，那么该线程将直接获得锁。
3. **无需解锁**：只有当持有偏向锁的线程退出同步块时，才会设置锁标记为无锁状态，但不会真正执行解锁操作。
### 偏向锁撤销
虽然偏向锁可以提高程序性能，但在存在多线程竞争的情况下，持有偏向锁的线程可能不再活跃，或者其他线程尝试获取这个锁，这时就需要撤销偏向锁。撤销偏向锁涉及一些开销，因为它需要停止所有的线程（Stop-The-World, STW），然后撤销锁的偏向状态，从而允许其他线程有机会获得这个锁。
#### 撤销过程

1. **检测到竞争**：当另一个线程尝试获取已经偏向某一线程的锁时，JVM会检测到这种竞争状态。
2. **暂停所有线程**：JVM通过一次STW事件暂停所有线程，确保没有线程正在执行与锁相关的代码。
3. **锁状态转换**：JVM会清除锁对象头中的偏向标记，并将锁状态转换为轻量级锁或重量级锁，取决于当前的竞争程度。
4. **恢复执行**：转换完成后，所有线程恢复执行。尝试获取锁的线程将会进入正常的锁竞争。
## 轻量级锁
轻量级锁是Java虚拟机（JVM）中用于优化锁性能的一种锁机制，它介于偏向锁和重量级锁之间。轻量级锁主要用于减少无竞争锁的同步开销，在多线程环境下，当锁竞争不是特别激烈时，使用轻量级锁可以提高性能。
### 工作原理
轻量级锁的工作原理基于锁记录（Lock Record）和对象头的CAS（Compare And Swap）操作：

1. **锁记录创建**：当线程尝试获取一个锁时，JVM首先检查该锁是否为可偏向状态。如果已经是偏向锁且偏向其他线程，或者是无锁状态但有竞争，JVM将在当前线程的栈帧中创建一个锁记录（Lock Record）。
2. **CAS尝试加锁**：线程使用CAS操作尝试将对象头的Mark Word更新为指向锁记录的指针。如果CAS操作成功，线程获得锁且锁变为轻量级锁状态；如果失败，表示其他线程也在竞争这个锁。
3. **锁膨胀**：如果CAS失败，JVM会检查失败的原因。如果是其他线程已经持有轻量级锁，则当前线程进入自旋，尝试几次（自旋次数是有限的）后，如果仍然不能获得锁，轻量级锁会膨胀为重量级锁。
### 轻量级锁的释放
释放轻量级锁的过程相对简单：

1. **CAS操作释放**：当持有锁的线程退出同步块时，它会使用CAS操作尝试将对象头的Mark Word恢复到锁定前的状态（即从指向锁记录的指针改回原来的Mark Word）。
2. **释放成功与失败**：
   - 如果CAS操作成功，锁被成功释放。
   - 如果CAS操作失败，通常意味着有其他线程尝试获取这个锁，JVM可能需要唤醒正在等待这个锁的线程。
### 锁的膨胀
当轻量级锁的CAS释放操作失败，或者在尝试获取轻量级锁时多次失败，JVM会将轻量级锁膨胀为重量级锁。膨胀过程包括：

1. **创建重量级锁**：JVM会在堆上创建一个重量级锁（如OS的互斥锁），并将对象头的Mark Word更新为指向这个重量级锁的指针。
2. **唤醒等待线程**：转换为重量级锁后，JVM会通过操作系统的条件变量或相似机制，唤醒那些因为这个锁而阻塞的线程。
## 重量级锁
重量级锁是Java虚拟机（JVM）中一种基于操作系统的互斥锁机制，用于处理高度竞争的锁场景。当偏向锁和轻量级锁由于线程竞争而无法有效地维持锁状态时，JVM会将锁升级为重量级锁。这种锁利用操作系统提供的同步机制来管理线程的互斥和同步，确保在多线程环境中安全地访问共享资源。
### 工作原理

1. **锁升级**：当线程在尝试获取轻量级锁并通过自旋几次后仍然失败，或者在锁释放过程中检测到高竞争，JVM会将锁升级为重量级锁。这通常发生在有多个线程频繁尝试访问同一临界区的情况。
2. **互斥量**：重量级锁依赖于操作系统提供的互斥量（mutex）来实现线程同步。互斥量是一种使得在同一时间只有一个线程可以持有的锁。
3. **线程阻塞和唤醒**：当一个线程尝试获取已被其他线程持有的重量级锁时，该线程会在操作系统层面被挂起（阻塞）。当持有锁的线程释放锁时，操作系统负责唤醒一个或多个等待的线程，并允许它们再次尝试获取锁。
### 锁的获取和释放

1. **获取重量级锁**：当一个线程尝试获取重量级锁时，它首先检查锁的状态。如果锁未被持有，线程将锁标记为自己持有，并继续执行。如果锁已经被其他线程持有，该线程会被操作系统挂起，直到锁被释放。
2. **释放重量级锁**：当锁的持有者完成其临界区的代码后，它将释放锁，通常通过将锁的状态设置回未锁定状态，并通知操作系统唤醒等待该锁的线程之一。
# 锁的分类
Java 提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。我们可以通过特性将锁进行分组归类。
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1715608948709-18f8496a-1271-4b2e-941f-2db898b67e07.png#averageHue=%23fdfdfc&clientId=ud25c4abf-d891-4&from=paste&height=741&id=u309dbd3e&originHeight=1206&originWidth=1372&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc096329e-2c3f-4c0c-8557-b81c080a42b&title=&width=843)
## 乐观锁 and 悲观锁
### 悲观锁
**概念**：

- 悲观锁基于这样的假设：在多线程环境中，冲突是常态，因此在操作数据前必须先持有锁。这种方式防止了数据在读取和写入期间被其他线程修改。

**实现方式**：

- 在Java中，**synchronized** 关键字和 **ReentrantLock** 是实现悲观锁的常用方法。这些锁在访问共享资源前阻塞其他所有的访问尝试，直到锁被释放。

**优点**：

- 简单直接，通过阻止并发执行，保证了数据的完整性和一致性。
- 在竞争不激烈的情况下，可以很容易地实现并保证性能。

**缺点**：

- 可能导致线程阻塞和等待，增加了系统的响应时间和资源消耗。
- 死锁风险，尤其在有多个锁时，如果不当地管理锁的获取和释放顺序，可能导致系统挂起。
### 乐观锁
**概念**：

- 乐观锁基于这样的假设：在多线程环境中，冲突是罕见的，因此不需要持续持有锁，而是在数据提交时验证是否发生了冲突。如果检测到冲突，根据实现策略重试当前操作或放弃。

**实现方式**：

- 乐观锁常通过CAS（比较并交换）操作实现，这在Java中通过如**AtomicInteger**这样的原子类体现。这些原子类使用CPU的原子指令直接在内存中进行值的比较和更新，而不需要阻塞线程。

**优点**：

- 避免了线程阻塞，提高了系统的整体吞吐量。
- 在数据竞争较少的环境中，性能优于悲观锁。

**缺点**：

- 在高度竞争的环境下，频繁的冲突和重试可能导致性能问题。
- 实现复杂，需要处理回滚和重试逻辑。
### 总结
选择乐观锁或悲观锁应根据具体的应用场景和数据访问模式来决定。乐观锁适用于读多写少，冲突少的场景，而悲观锁适用于写多读少，冲突多的环境。
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1715609200887-c20d4df2-51c8-4851-a9ca-ce2f3b84b882.png#averageHue=%23f6f3ee&clientId=ud25c4abf-d891-4&from=paste&id=u009bd3a6&originHeight=1462&originWidth=1898&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u02e683e0-f2b2-4db4-93da-6cadeeb6393&title=)
## 自旋锁 and 适应性自旋锁
自旋锁和适应性自旋锁是两种在并发编程中用来避免线程切换开销的技术。这两种锁通常用于优化多线程程序，尤其是在锁持有时间很短的情况下。下面是对这两种锁的解释和比较：
### 自旋锁
**概念**：

- 自旋锁是一种忙等待锁，当线程尝试获取锁而锁被其他线程持有时，线程不会立即阻塞。相反，线程会在循环中反复检查锁是否可用。这意味着线程会持续消耗CPU资源，直到它能获取锁。

**应用场景**：

- 自旋锁适用于锁持有时间非常短的情况，因为线程不会进入休眠状态，从而避免了线程调度的开销。

**优点**：

- 减少线程状态变化带来的开销，因为不涉及操作系统的线程调度。
- 对于锁持有时间极短的代码块，自旋锁可以提高程序性能。

**缺点**：

- 如果锁被持有时间较长，自旋锁会导致大量的CPU时间浪费在无意义的循环上，从而降低系统整体性能。
- 在单核处理器上，自旋锁可能会非常低效，因为没有其他核可用来真正并行地运行其他线程。
### 适应性自旋锁 
**概念**：

- 适应性自旋锁是自旋锁的一个改进版本。它不是简单地无限期地循环等待锁变为可用，而是根据之前获取锁的历史信息来决定自旋的时间。如果历史上获取锁的时间很短，它会进行更长时间的自旋；如果获取锁的时间很长，它会减少自旋时间或者放弃自旋，转而使线程阻塞。

**应用场景**：

- 适应性自旋锁适用于锁持有时间不确定的情况，尤其是在多核处理器上。

**优点**：

- 动态调整自旋时间，能更有效地利用CPU资源。
- 在多核系统中，可以根据系统的实时性能反馈调整策略，提高并发性能。

**缺点**：

- 实现复杂，需要维护更多的运行时信息。
- 在高竞争的环境下，过度自旋仍可能导致CPU资源浪费。
### 总结
自旋锁和适应性自旋锁都是为了优化线程在并发环境中的性能，特别是减少线程切换带来的开销。适应性自旋锁通过智能地决定何时自旋何时阻塞，提供了一种更为高效的同步方式，适合更广泛的场景
## 可重入锁 and 非可重入锁
可重入锁（Reentrant Lock）和非可重入锁（Non-Reentrant Lock）是两种不同的锁机制，它们主要区别在于是否允许同一线程多次获取同一把锁而不发生死锁。这两种锁的行为对于设计并发控制机制非常关键。以下是对这两种锁的详细解释和区别：
### 可重入锁
**概念**：

- 可重入锁允许同一个线程多次获得同一把锁。这意味着如果一个线程已经持有某个锁，它可以再次请求并获得这个锁而不会被阻塞。这是通过跟踪持有锁的线程和持有锁的计数来实现的。每次获得锁时，计数增加；每次释放锁时，计数减少。当计数归零时，锁被释放。

**实现方式**：

- 在Java中，**synchronized** 关键字和 **java.util.concurrent.locks.ReentrantLock** 类提供了可重入锁的实现。这些锁支持在同一个线程中多次加锁和解锁。

**优点**：

- 避免了死锁问题，特别是在一个线程需要调用同一个锁保护的多个方法时。
- 增加编程灵活性，允许在一个被锁保护的方法中调用另一个使用相同锁的方法。

**缺点**：

- 可能导致过度同步。由于过于依赖锁的可重入性，可能使得程序过分依赖同步，而不是寻找其他可能更高效的并发策略。
#### 演示
假设我们有一个类，它用于管理用户的账户信息。这个类包含两个方法：一个是用来增加用户余额的方法，另一个是检查并更新用户的信用额度。这两个方法都需要同步，以防止数据竞争。
**deposit** 方法调用了另一个同步方法 **checkCredit**。由于 **synchronized** 关键字允许可重入，所以同一个线程可以在已经持有锁的情况下再次获得同一个锁。
```java
public class AccountManager {
    private double balance = 0.0;
    private double creditLimit = 1000.0;

    // 可重入锁的示例：使用 synchronized 关键字
    public synchronized void deposit(double amount) {
        System.out.println("Depositing " + amount);
        this.balance += amount;
        checkCredit(); // 再次调用另一个 synchronized 方法
    }

    public synchronized void checkCredit() {
        if (balance > creditLimit) {
            System.out.println("Credit limit exceeded");
        } else {
            System.out.println("Credit limit okay");
        }
    }

    public static void main(String[] args) {
        AccountManager manager = new AccountManager();
        manager.deposit(1200.0);
    }
}

```
### 非可重入锁
**概念**：

- 非可重入锁不允许同一线程多次获得同一把锁。如果一个线程已经持有锁，再次请求同一锁时，即使是同一个线程也会导致锁的请求阻塞。这种锁通常简单，但在某些情况下可能引发死锁。

**实现方式**：

- 在一些低级的锁实现或某些特定的编程环境中，锁可能默认是非可重入的。例如，某些自定义的锁机制或者早期的同步原语可能不支持重入。

**优点**：

- 实现简单。不需要跟踪所有的锁请求，从而减少了系统的复杂性。

**缺点**：

- 风险较高，特别是在复杂的应用中，非可重入锁可能意外导致死锁，特别是当一个线程在持有锁的同时试图再次获取同一锁时。
#### 演示
假设我们使用一个简化的非可重入锁实现。为了演示，我们假设有一个自定义锁，这个锁在试图被同一线程再次获取时不会成功。
当 **deposit** 方法调用 **checkCredit** 时，尝试再次获取已被同一线程持有的锁将会失败。这将导致线程阻塞，从而产生死锁。
```java
class NonReentrantLock {
    private boolean isLocked = false;

    public synchronized void lock() throws InterruptedException {
        while (isLocked) {
            wait(); // 等待直到锁被释放
        }
        isLocked = true;
    }

    public synchronized void unlock() {
        isLocked = false;
        notify();
    }
}

public class AccountManagerWithNonReentrantLock {
    private double balance = 0.0;
    private NonReentrantLock lock = new NonReentrantLock();

    public void deposit(double amount) throws InterruptedException {
        lock.lock();
        try {
            System.out.println("Depositing " + amount);
            this.balance += amount;
            checkCredit(); // 尝试再次获取同一锁
        } finally {
            lock.unlock();
        }
    }

    public void checkCredit() throws InterruptedException {
        lock.lock();
        try {
            System.out.println("Checking credit");
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        AccountManagerWithNonReentrantLock manager = new AccountManagerWithNonReentrantLock();
        manager.deposit(1200.0); // 这将导致死锁，因为 lock() 在 checkCredit() 中再次被调用
    }
}
```
### 总结
可重入锁在现代编程中使用较为广泛，因为它们提供了更大的灵活性和错误预防机制，尤其是在面对复杂的同步需求时。非可重入锁则因其潜在的死锁风险而较少使用，除非在特定的低级编程任务或者性能极为关键的场景中。在设计并发控制时，了解和选择合适的锁类型是确保应用稳定和高效的关键因素。
## 公平锁 and 非公平锁
### 公平锁
**概念**：

- 公平锁是一种确保获取锁的顺序按照线程到达的顺序进行的锁。也就是说，如果线程A比线程B先到达锁的排队队列，那么线程A将会比线程B先得到锁，即使在线程B到达后锁变得可用时，锁系统也会等待线程A先获取锁。

**实现方式**：

- 在Java中，**ReentrantLock** 类在创建时可以带有一个布尔参数来决定是否是公平锁。如果设置为**true**，则为公平锁；如果为**false**（默认值），则为非公平锁。

**优点**：

- 防止饥饿：所有线程最终都将获得锁的机会，避免了某些线程永远获取不到锁的情况（即饥饿）。
- 线程处理有序：确保了线程处理的顺序性和可预测性。

**缺点**：

- 性能开销大：管理和维护线程队列可能导致更大的延时。由于锁需要检查队列中的线程顺序，因此公平锁通常比非公平锁性能要低。
### 非公平锁
**概念**：

- 非公平锁允许加塞，即后来的线程可以在排队的线程之前获取锁，如果在请求锁的时候锁刚好是可用状态。这种类型的锁不保证任何请求锁的顺序。

**实现方式**：

- **ReentrantLock** 的默认行为就是非公平锁，或者在创建时显式设置其构造函数的参数为**false**。

**优点**：

- 性能较高：因为线程通常不需要按顺序排队，所以减少了额外的处理延迟，这可能导致整体上的性能提升。

**缺点**：

- 可能导致饥饿：一些线程可能会等待非常长的时间或甚至无法获取锁，特别是在高负载的情况下。
- 不可预测性：锁的分配更随机，程序的行为可能难以预测。
### 总结
选择使用公平锁还是非公平锁通常取决于应用的具体需求：

- 如果应用需要保证线程的处理顺序，并且可以接受一定的性能开销，公平锁可能是更好的选择。
- 如果应用的优先级是性能，而且可以容忍线程获取锁的不确定性，那么非公平锁可能更合适。
## 读写锁 and 排它锁
读写锁（Read-Write Lock）和排它锁（Exclusive Lock，通常也称为互斥锁 Mutex）是两种不同的锁机制，用于控制多线程对共享资源的访问，以防止数据竞争和保证数据一致性。它们各自适用于不同的应用场景，具有各自的优势和缺点。
### 读写锁
**概念**：

- 读写锁允许多个读线程同时访问共享资源，但只允许一个写线程访问，且写线程访问时不允许任何读线程或其他写线程进行访问。这种锁是为了优化访问共享资源的性能，特别是在读操作远多于写操作的情况下。

**实现方式**：

- 在Java中，**ReadWriteLock** 接口及其实现类 **ReentrantReadWriteLock** 提供了读写锁的功能。使用两个锁 - 一个读锁和一个写锁。读锁可以被多个读线程共享，写锁是独占的。

**优点**：

- 提高性能：在读多写少的场景下，可以显著提高系统性能，因为多个读线程可以同时读取数据而不阻塞彼此。
- 灵活性：提供了比排它锁更高的并发级别。

**缺点**：

- 复杂性：管理两种类型的锁（读锁和写锁）比单一的互斥锁复杂。
- 可能的饥饿问题：如果读操作非常频繁，写线程可能会长时间等待获取写锁。
### 排它锁
**概念**：

- 排它锁是一种只允许一个线程在同一时间对共享资源进行访问的锁。任何时刻，只有一个线程可以持有排它锁，如果其他线程希望获得同一个锁，它们必须等待直到锁被释放。

**实现方式**：

- 在Java中，**synchronized** 关键字和 **ReentrantLock** 的普通使用都提供了排它锁的功能。

**优点**：

- 简单易用：使用广泛，容易理解和实现。
- 保证安全性：防止数据竞争和保证操作的原子性。

**缺点**：

- 性能问题：所有的写操作和读操作都是串行的，可能会导致大量的线程阻塞，尤其是在高负载环境下。
- 可能导致死锁：如果不正确地管理锁的获取和释放顺序。
### 总结
读写锁和排它锁的选择取决于你的应用场景：

- 如果你的应用或系统中读操作明显多于写操作，并且需要支持高并发，读写锁可能更合适。
- 如果你的应用中对数据一致性的要求非常高，且写操作频繁，或者你更倾向于简化设计以避免复杂的锁管理，排它锁可能是更好的选择。
> 部分内容转载：
> 1. [二哥进阶之路 · synchronized的四种锁状态](https://javabetter.cn/thread/synchronized.html)
> 2. [二哥进阶之路 · 锁的分类](https://javabetter.cn/thread/lock.html)

