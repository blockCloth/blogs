## 乐观锁和CAS
### 乐观锁与悲观锁
锁可以从不同的角度来分类。比如我们在前面讲 synchronized 四种锁状态的时候，提到过偏向锁、轻量级锁、重量级锁，乐观锁和悲观锁也是一种分类方式。
#### 悲观锁
对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。synchronized 就是悲观锁
#### 乐观锁
乐观锁，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 CAS 的技术来保证线程执行的安全性。
由于乐观锁假想操作中没有锁的存在，因此不太可能出现死锁的情况，换句话说，**乐观锁天生免疫死锁**。

- 乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；
- 悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。
### 什么是CAS
在 CAS 中，有这样三个值：

- **V：要更新的变量(var)**
- **E：预期值(expected)**
- **N：新值(new)**

比较并交换的过程如下：
判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。
这里的**预期值 E 本质上指的是“旧值”**。
我们以一个简单的例子来解释这个过程：

1. 如果有一个多个线程共享的变量i原本等于 5，我现在在线程 A 中，想把它设置为新的值 6;
2. 我们使用 CAS 来做这个事情；
3. 首先我们用 i 去与 5 对比，发现它等于 5，说明没有被其它线程改过，那我就把它设置为新的值 6，此次 CAS 成功，i的值被设置成了 6；
4. 如果不等于 5，说明i被其它线程改过了（比如现在i的值为 2），那么我就什么也不做，此次 CAS 失败，i 的值仍然为2

在这个例子中，i就是 V，5 就是 E，6 就是 N。
那有没有可能我在判断了i为 5 之后，正准备更新它的新值的时候，被其它线程更改了i的值呢？
不会的。因为 CAS 是一种原子操作，它是一种系统原语，是一条 CPU 的原子指令，从 CPU 层面已经保证它的原子性。
**当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。**
### CAS的三种问题
CAS（Compare-and-Swap）操作，虽然是一种有效的无锁编程手段，确实存在一些问题或局限性，特别是在高并发场景中。主要问题包括ABA问题、循环时间长和CPU资源消耗大。下面详细解释这些问题及其潜在的解决策略：
#### 1. ABA问题

- **问题描述**：在CAS操作中，如果一个变量 **A** 在经过一系列操作后被改变为另一个值 **B**，然后又被改回原来的值 **A**，CAS操作将无法感知中间发生的变化（即A变为B再变回A的过程）。这在某些应用场景中可能会导致错误。
- **解决方案**：一种常见的解决方法是使用版本号或时间戳。每次变量更新时，版本号增加。这样，即使数据回到原始状态，版本号的变化也能防止CAS操作错误地成功。
#### 2. 循环时间长和CPU资源消耗大

- **问题描述**：当多个线程试图同时使用CAS更新同一个变量时，只有一个线程会成功，其他线程需要重新尝试。在高竞争的环境下，这些线程可能需要很多次尝试才能成功，这会导致循环时间长，并且消耗大量的CPU资源。
- **解决方案**：
   - **回退策略**：可以实施一种回退策略，如指数后退，在失败后暂停一段随机时间再尝试。这可以减少冲突和CPU的过度消耗。
   - **使用其他机制**：在高度竞争的环境中，可能需要考虑使用传统的锁或其他并发机制，比如Java的 **ReentrantLock**，这些机制提供了更复杂的调度策略来处理高竞争。
#### 3. 只能保证单个变量的原子操作

- **问题描述**：CAS仅能够保证对单个共享变量的原子操作。如果需要同时更新多个共享变量，单个CAS操作无法保证操作的原子性。
- **解决方案**：
   - **使用锁**：对于多个变量的原子性操作，可以使用锁（如 **synchronized** 或 **ReentrantLock**）来保证原子性。
   - **复合变量**：在Java中，可以使用类似 **AtomicReference** 的复合原子变量，通过它可以将多个变量包装在一个对象中进行CAS操作。
> 转载：
> 1. 二哥的进阶之路 · 乐观锁和CAS

