## 类加载过程
类从被加载到 JVM 开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。
出去使用和卸载，就是Java 的类加载过程。这5个阶段一般是顺序发生的，但是在动态绑定的情况下，解析阶段发生在初始化阶段之后。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/22796888/1716801576649-1d1119bc-479a-4022-a6ac-7fc0575ef228.png#averageHue=%23faf8f7&clientId=u70911639-e0cd-4&from=paste&height=673&id=ua8b8f252&originHeight=958&originWidth=1178&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=89067&status=done&style=none&taskId=u543105b5-73ad-4c58-a8db-99385b91668&title=&width=828)
### 七个阶段类比
假设我们有一个公司，它招聘新员工、对员工进行背景核实、培训员工、分配任务、员工开始工作，最后员工离职的过程。这一系列步骤对应于Java类在JVM中的生命周期阶段。
#### 加载（Loading）

   - **现实类比**：公司发布招聘广告并接收应聘者的简历。
   - **JVM中的过程**：类加载器（Class Loader）找到并读取类的字节码文件（.class文件）到内存中。
#### 验证（Verification）

   - **现实类比**：公司对应聘者进行背景调查，核实其学历、工作经验等信息，确保其符合公司的要求。
   - **JVM中的过程**：JVM验证字节码文件的格式和内容，确保其符合Java语言规范，避免恶意代码破坏JVM的安全性。
      - 确保二进制字节流格式符合预期（比如说是否以`cafe bene`开头）；
      - 是否所有方法都遵循访问控制关键字的限定，`protected、private` 那些；
      - 方法调用的参数个数和类型是否正确；
      - 确保变量在使用之前是否被正确初始化了；
      - 检查变量是否被赋予恰当类型的值；
#### 准备（Preparation）

   - **现实类比**：公司为新员工准备办公桌、电脑、工牌等工作设备。
   - **JVM中的过程**：JVM为类的静态变量分配内存，并将其初始化为默认值（如零值、null、false等）。
#### 解析（Resolution）

   - **现实类比**：公司安排新员工与各部门负责人见面，了解公司的工作流程和各部门的职责。
   - **JVM中的过程**：JVM将类的符号引用（如类名、方法名）转换为实际的内存地址，该阶段将常量池中的符号引用转化为直接引用。
#### 初始化（Initialization）

   - **现实类比**：新员工接受入职培训，熟悉具体工作任务和职责，开始正式工作。
   - **JVM中的过程**：执行类的初始化代码，包括静态初始化块和静态变量的赋值语句。此时，类的静态变量被赋予实际值。
   - **初始化时机：**
      - 创建类的实例时；
      - 访问类的静态方法或者静态字段时（除了 final 常量），它们在编译期就已经放入了常量池；
      - 使用`java.lang.reflect`包的方法对类进行反射调用时；
      - 初始化一个类的子类（首先会初始化父类）；
      - JVM 启动时，用户指定的主类（包含 main 方法的类）将被初始化；
#### 使用（Usage）

   - **现实类比**：员工在公司正常工作，完成日常任务和项目。
   - **JVM中的过程**：类被实际使用，包括创建类的实例、调用类的方法、访问类的字段等。
#### 卸载（Unloading）

   - **现实类比**：员工离职，公司回收其工作设备，取消其系统访问权限。
   - **JVM中的过程**：当JVM确定类不再需要时，释放类占用的内存。
### 符号引用 and 直接引用
#### 符号引用
##### 定义
符号引用是一种间接的引用方式，用于在编译时描述类、方法、字段等的全限定名，而不是它们在内存中的实际地址。
##### 特点

- **编译时生成**：在Java代码编译成字节码时生成。
- **存储位置**：存储在类文件的常量池中。
- **独立于内存地址**：符号引用不依赖于实际内存地址，因此具有更好的灵活性和可移植性。
##### 举例

- **类引用**：**com/example/MyClass**
- **方法引用**：**com/example/MyClass.myMethod()V**
- **字段引用**：**com/example/MyClass.myField**
##### 优点

- **灵活性**：符号引用可以在不同的JVM实例中使用相同的字节码文件而无需修改。
- **解耦性**：符号引用使得编译时和运行时解耦，编译器不需要知道目标的实际内存地址。
#### 直接引用
##### 定义
直接引用是一种具体的引用方式，用于在运行时指向类、方法、字段等在内存中的实际地址或偏移量。
##### 特点

- **运行时生成**：在类加载和解析阶段生成。
- **依赖于内存布局**：直接引用依赖于内存中的实际布局，指向具体的内存地址或偏移量。
- **高效访问**：由于直接引用指向实际的内存地址，访问速度较快，性能更好。
##### 举例

- **指针**：直接指向内存地址，例如**0x7ffe12345678**。
- **偏移量**：相对于某个基地址的偏移，例如基地址为**0x7ffe00000000**，偏移量为**0x000012345678**。
##### 优点

- **高效性**：直接引用提供了快速访问内存中对象的能力，运行时性能较高。
- **准确性**：直接引用能直接指向目标在内存中的具体位置，避免了间接引用的开销。
#### 符号引用与直接引用的转换过程
##### 解析阶段
在JVM中，解析阶段负责将符号引用转换为直接引用。这一过程主要发生在类加载时或方法首次调用时。

- **类或接口解析**：将符号引用的类名或接口名解析为实际的类对象或接口对象，并获取它们在内存中的地址。
- **方法解析**：将符号引用的方法名和描述符解析为实际的方法对象，并获取它们在内存中的地址。
- **字段解析**：将符号引用的字段名解析为实际的字段对象，并获取它们在内存中的地址。
##### 动态绑定的情况
在某些动态绑定的情况下（如使用反射或动态代理），解析阶段可能在类的初始化之后进行。这意味着符号引用在实际使用时才会被解析为直接引用。
#### 现实类比
为了更直观地理解符号引用和直接引用，我们可以将其类比为图书馆中的书籍引用方式：

- **符号引用**：就像书籍目录中的条目，描述书籍的名称和作者，但不直接告诉你书籍在图书馆的具体位置。
- **直接引用**：就像书架上的书籍实际位置，告诉你书籍在图书馆中具体的书架和位置，可以直接找到书籍。
#### 举例说明
假设我们有以下Java代码：
```java
public class A {
    public B b;

    public void myMethod() {
        b.doSomething();
    }
    
}

public class B {
    
    public void doSomething() {
        System.out.println("Doing something");
    }
    
}
```
##### 编译时（符号引用）

- **A**类的常量池中包含符号引用**B**类：**Lcom/example/B;**
- **A**类的方法**myMethod**中包含对**B**类的符号引用：**com/example/B.doSomething()V**
##### 运行时（直接引用）

- JVM在解析阶段将符号引用**Lcom/example/B;**解析为**B**类的实际内存地址。
- JVM在方法调用时将符号引用**com/example/B.doSomething()V**解析为**B**类的**doSomething**方法的实际内存地址。
#### 总结
符号引用和直接引用是Java类加载和运行时的两个重要概念。符号引用在编译时生成，存储在类文件的常量池中，独立于具体的内存地址。直接引用在运行时生成，指向内存中的实际对象或方法，具有更高的访问效率。在解析阶段，JVM负责将符号引用转换为直接引用，以实现高效的内存访问和对象操作。
## 类加载器
![image.png](https://cdn.nlark.com/yuque/0/2024/png/22796888/1716818710260-840775cb-8d8c-4f0f-9746-a39d57dbbdd3.png#averageHue=%23cde2c9&clientId=u6dde52c7-555d-4&from=paste&height=350&id=uf5ffe52a&originHeight=438&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115922&status=done&style=none&taskId=ubb1e16c5-bff7-438f-87da-a170212dcdd&title=&width=864)
**类加载器主要分为四种类型：**

1. **引导类加载器（Bootstrap ClassLoader）：**负责加载 JVM 基础核心类库，如 `rt.jar、sun.boot.class.path`路径下的类；
2. **扩展性加载器（Extension ClassLoader）：**负责加载 Java 扩展库中的类，例如`jre.lib.ext`目录下的类或由系统属性`java.ext.dirs`指定位置的类；
3. **系统（应用）类加载器（System ClassLoader）：**负责加载系统类路径`java.class.path`上指定的类库，通常是你的应用类和第三方库；
4. **用户自定义类加载器：**Java 允许用户创建自己的类加载器，通过继承`java.lang.ClassLoader`类的方式实现。在这需要加载资源、实现模块化框架或者特殊的类加载策略时非常有用；

一般来说，Java 程序员并不需要直接同类加载器进行交互。JVM 默认的行为就已经足够满足大多数情况的需求了。不过，如果遇到了需要和类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就不得不花大量的时间去调试 **ClassNotFoundException** 和 **NoClassDefFoundError** 等异常（前面讲过）。
对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性。也就是说，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等（比如两个类的 **Class** 对象不 **equals** ）。
来通过一段简单的代码了解下。每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 **类名.class.getClassLoader()** 可以获取到此引用；然后通过 **loader.getParent()** 可以获取类加载器的上层类加载器。
```java
public class Test {
    public static void main(String[] args) {
        ClassLoader loader = Test.class.getClassLoader();
        while (loader != null) {
            System.out.println(loader);
            loader = loader.getParent();
        }
    }
}

输出结果：
    jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17
    jdk.internal.loader.ClassLoaders$PlatformClassLoader@2d209079
```
## 双亲委派模型（Parent Delegation Model）
双亲委派模型是Java类加载器使用的一种机制，用于确保Java程序的稳定性和安全性。在这个模型中，类加载器在尝试加载一个类时，首先会委派给其父加载器去尝试加载这个类，只有在父加载器无法加载该类时，子加载器才会尝试自己去加载。
### 关键步骤

1. **委派给父加载器**：
   - 当一个类加载器接收到类加载的请求时，它首先不会尝试自己去加载这个类，而是将这个请求委派给它的父加载器。
2. **递归委派**：
   - 这个过程会递归向上进行，从启动类加载器（Bootstrap ClassLoader）开始，再到扩展类加载器（Extension ClassLoader），最后到系统类加载器（System ClassLoader）。
3. **加载类**：
   - 如果父加载器可以加载这个类，那么就使用父加载器的结果。如果父加载器无法加载这个类（它没有找到这个类），子加载器才会尝试自己去加载。
4. **安全性和避免重复加载**：
   - 这种机制可以确保不会重复加载类，并保护Java核心API的类不被恶意替换。
### 类加载器的层级结构
双亲委派模型的层次关系如下：
```markdown
启动类加载器（Bootstrap ClassLoader）
        |
        |
扩展类加载器（Extension ClassLoader）
        |
        |
系统类加载器（System ClassLoader）
        |
        |
自定义类加载器（Custom ClassLoader）
```
这种层次关系被称为双亲委派模型：如果一个类加载器收到了加载类的请求，它会先把请求委托给上层加载器去完成，上层加载器又会委托上上层加载器，一直到最顶层的类加载器；如果上层加载器无法完成类的加载工作时，当前类加载器才会尝试自己去加载这个类。
### 优点

- **稳定性和安全性**：
   - 确保Java类不会被重复加载，避免了类定义的冲突。
   - 保护Java核心API类不被恶意替换。
- **层次关系和优先级**：
   - Java类随着类加载器具备了优先级的层次关系，这对于保证Java程序的稳定运行非常重要。
### 总结
双亲委派模型确保类加载的稳定性和安全性，通过递归委派机制避免类的重复加载，并保护核心类库不被替换。理解这个模型有助于Java程序员更好地处理类加载相关的问题和异常，如 **ClassNotFoundException** 和 **NoClassDefFoundError**。
